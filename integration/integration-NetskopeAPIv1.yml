category: Network Security
commonfields:
  id: NetskopeAPIv1
  version: -1
configuration:
- display: Server URL
  name: url
  required: true
  type: 0
- display: ""
  displaypassword: API token
  hiddenusername: true
  name: credentials
  required: true
  type: 9
- defaultvalue: "50"
  display: Maximum incidents per fetch. Max value is 200.
  name: max_fetch
  required: true
  type: 0
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, like 12 hours, 7 days)
  name: first_fetch
  required: false
  type: 0
- additionalinfo: Free text query to filter the fetched alerts. For more information,
    please visit Netskope documentation (https://docs.netskope.com/en/get-alerts-data.html).
  display: Alerts Query
  name: alerts_query
  required: false
  type: 0
- additionalinfo: Fetch events as incidents, in addition to the alerts.
  display: Fetch Events
  name: fetch_events
  required: false
  type: 8
- additionalinfo: The event types to fetch as incidents. The API requires specifying
    the event types.
  display: Event types to fetch.
  name: event_types
  options:
  - page
  - application
  - audit
  - infrastructure
  - network
  required: false
  type: 16
- defaultvalue: "50"
  display: Maximum events as incidents per fetch. Max value is 200.
  name: max_events_fetch
  required: false
  type: 0
- additionalinfo: Free text query to filter the fetched events (if configured). For
    more information, please visit Netskope documentation (https://docs.netskope.com/en/get-events-data.html).
  display: Events Query
  name: events_query
  required: false
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.2.0
    itemVersion: 3.3.1
    packID: Netskope
    packName: Netskope
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Get alerts and events, manage quarantine files as well as URL and hash
  lists using Netskope API v1.
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/netskope-ap-iv1)'
display: Netskope (API v1)
image: data:image/png;base64,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
name: NetskopeAPIv1
script:
  commands:
  - arguments:
    - description: 'Free query to filter the events. For example, "app eq Dropbox".
        For more information, please visit Netskope documentation: https://docs.netskope.com/en/get-events-data.html'
      name: query
    - auto: PREDEFINED
      description: Select events by their type.
      name: event_type
      predefined:
      - page
      - application
      - audit
      - infrastructure
      - network
      required: true
    - auto: PREDEFINED
      description: Get all events from a certain time period.
      name: timeperiod
      predefined:
      - Last 60 Minutes
      - Last 24 Hours
      - Last 7 Days
      - Last 30 Days
      - Last 60 Days
      - Last 90 Days
    - description: Restrict events to those that have dates greater than the provided
        date string.
      name: start_time
    - description: Restrict events to those that have dates less than or equal to
        the provided date string.
      name: end_time
    - description: Restrict events to those that were inserted to the system after
        the provided date string.
      name: insertion_start_time
    - description: Restrict events to those that were inserted to the system before
        the provided date string.
      name: insertion_end_time
    - defaultValue: "50"
      description: The maximum amount of events to retrieve.
      name: limit
    - defaultValue: "1"
      description: The page number of the events to retrieve (minimum is 1).
      name: page
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, the returned data will not be sorted (useful for improved
        performance).
      name: unsorted
      predefined:
      - "true"
      - "false"
    description: Get events extracted from SaaS traffic and or logs. You must provide
      start_time and end_time, or insertion_start_time and insertion_end_time, or
      timeperiod. Also, you cannot provide a combination of the options mentioned
      above.
    name: netskope-event-list
    outputs:
    - contextPath: Netskope.Event.event_id
      description: The unique identifier of the event.
      type: String
    - contextPath: Netskope.Event.timestamp
      description: Unix epoch timestamp when the event happened in.
      type: Number
    - contextPath: Netskope.Event.type
      description: Shows if it is an application event or a connection event.
      type: String
    - contextPath: Netskope.Event.access_method
      description: Cloud app traffic can be steered to the Netskope cloud using different
        deployment methods such as Client (Netskope Client), Secure Forwarder etc.
      type: String
    - contextPath: Netskope.Event.traffic_type
      description: 'Type of the traffic: CloudApp or Web.'
      type: String
    - contextPath: Netskope.Event.count
      description: Number of raw log lines/events sessionized or suppressed during
        the suppressed interval.
      type: Number
    - contextPath: Netskope.Event.app
      description: Specific cloud application used by the user (e.g. app = Dropbox).
      type: String
    - contextPath: Netskope.Event.appcategory
      description: Application Category as designated by Netskope.
      type: String
    - contextPath: Netskope.Event.url
      description: URL of the application that the user visited as provided by the
        log or data plane traffic.
      type: String
    - contextPath: Netskope.Event.page
      description: The URL of the originating page.
      type: String
    - contextPath: Netskope.Event.domain
      description: Domain value.
      type: String
    - contextPath: Netskope.Event.object
      description: Name of the object which is being acted on.
      type: String
    - contextPath: Netskope.Event.object_id
      description: Unique ID associated with an object.
      type: String
    - contextPath: Netskope.Event.activity
      description: Description of the user performed activity.
      type: String
    - contextPath: Netskope.Event.device
      description: Device type from where the user accessed the cloud app.
      type: String
    - contextPath: Netskope.Event.category
      description: The event category.
      type: String
  - arguments:
    - description: 'Free query to filter the alerts. For example, "alert_name like
        test". For more information, please visit Netskope documentation: https://docs.netskope.com/en/get-alerts-data.html'
      name: query
    - auto: PREDEFINED
      description: Select alerts by their type.
      name: alert_type
      predefined:
      - anomaly
      - Compromised Credential
      - policy
      - Legal Hold
      - malsite
      - Malware
      - DLP
      - Security Assessment
      - watchlist
      - quarantine
      - Remediation
      - uba
    - auto: PREDEFINED
      description: Whether to retrieve acknowledged alerts or not.
      name: acked
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Get alerts from certain time period.
      name: timeperiod
      predefined:
      - Last 60 Minutes
      - Last 24 Hours
      - Last 7 Days
      - Last 30 Days
      - Last 60 Days
      - Last 90 Days
    - description: Restrict alerts to those that have dates greater than the provided
        date string.
      name: start_time
    - description: Restrict alerts to those that have dates less than or equal to
        the provided date string.
      name: end_time
    - description: Restrict alerts which have been inserted into the system after
        the provided date string.
      name: insertion_start_time
    - description: Restrict alerts which have been inserted into the system before
        the provided date string.
      name: insertion_end_time
    - defaultValue: "50"
      description: The maximum number of alerts to return.
      name: limit
    - defaultValue: "1"
      description: The page number of the alerts to retrieve (minimum is 1).
      name: page
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, the returned data will not be sorted (useful for improved
        performance).
      name: unsorted
      predefined:
      - "true"
      - "false"
    description: Get alerts generated by Netskope, including policy, DLP, and watch
      list alerts. You must provide start_time and end_time, or insertion_start_time
      and insertion_end_time, or timeperiod. Also, you cannot provide a combination
      of the options mentioned above.
    name: netskope-alert-list
    outputs:
    - contextPath: Netskope.Alert.alert_id
      description: The unique identifier of the alert.
      type: String
    - contextPath: Netskope.Alert.timestamp
      description: Timestamp when the event/alert happened.
      type: Number
    - contextPath: Netskope.Alert.type
      description: Shows if it is an application event or a connection event.
      type: String
    - contextPath: Netskope.Alert.access_method
      description: Cloud app traffic can be steered to the Netskope cloud using different
        deployment methods such as Client (Netskope Client), Secure Forwarder etc.
      type: String
    - contextPath: Netskope.Alert.traffic_type
      description: 'Type of the traffic: CloudApp or Web.'
      type: String
    - contextPath: Netskope.Alert.action
      description: Action taken on the event for the policy.
      type: String
    - contextPath: Netskope.Alert.count
      description: Number of raw log lines/events sessionized or suppressed during
        the suppressed interval.
      type: Number
    - contextPath: Netskope.Alert.alert_name
      description: Name of the alert.
      type: String
    - contextPath: Netskope.Alert.alert_type
      description: Type of the alert.
      type: String
    - contextPath: Netskope.Alert.acked
      description: Whether user acknowledged the alert or not.
      type: Boolean
    - contextPath: Netskope.Alert.policy
      description: Name of the policy configured by an admin.
      type: String
    - contextPath: Netskope.Alert.app
      description: Specific cloud application used by the user (e.
      type: String
    - contextPath: Netskope.Alert.appcategory
      description: Application Category as designated by Netskope.
      type: String
    - contextPath: Netskope.Alert.dlp_file
      description: File/Object name extracted from the file/object.
      type: String
    - contextPath: Netskope.Alert.dlp_profile
      description: DLP profile name.
      type: String
    - contextPath: Netskope.Alert.dlp_rule
      description: DLP rule that triggered.
      type: String
    - contextPath: Netskope.Alert.category
      description: The alert category.
      type: String
    - contextPath: Netskope.Alert.cci
      description: The cloud confidence index.
      type: Number
  - arguments:
    - description: Get files last modified after the provided date string.
      name: start_time
    - description: Get files last modified before the provided date string.
      name: end_time
    - defaultValue: "50"
      description: The maximum amount of clients to retrieve.
      name: limit
    - defaultValue: "1"
      description: The page number of the clients to retrieve (minimum is 1).
      name: page
    description: List all quarantined files.
    name: netskope-quarantined-file-list
    outputs:
    - contextPath: Netskope.Quarantine.quarantine_profile_id
      description: The ID of quarantine profile.
      type: String
    - contextPath: Netskope.Quarantine.quarantine_profile_name
      description: The name of quarantine profile.
      type: String
    - contextPath: Netskope.Quarantine.file_id
      description: The ID of the quarantined file.
      type: String
    - contextPath: Netskope.Quarantine.original_file_name
      description: The original filename before quarantining.
      type: String
    - contextPath: Netskope.Quarantine.policy
      description: The policy name caused quarantine the file.
      type: String
    - contextPath: Netskope.Quarantine.quarantined_file_name
      description: The filename after quarantining.
      type: String
    - contextPath: Netskope.Quarantine.user_id
      description: The ID of the user related to the quarantined file.
      type: String
  - arguments:
    - description: The ID of quarantine profile.
      name: quarantine_profile_id
      required: true
    - description: The ID of the quarantined file.
      name: file_id
      required: true
    description: Download a quarantined file.
    name: netskope-quarantined-file-get
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: Number
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.EntryID
      description: The entry ID of the file.
      type: String
    - contextPath: File.Info
      description: File information.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.Extension
      description: The file extension.
      type: String
  - arguments:
    - description: The profile ID of the quarantined file.
      name: quarantine_profile_id
      required: true
    - description: The ID of the quarantined file.
      name: file_id
      required: true
    - auto: PREDEFINED
      description: Action to be performed on a quarantined.
      name: action
      predefined:
      - block
      - allow
      required: true
    description: Take an action on a quarantined file.
    name: netskope-quarantined-file-update
  - arguments:
    - description: Name of an existing URL List shown in the Netskope UI on the URL
        List page.
      name: name
      required: true
    - description: A comma-separated list of URLs.
      isArray: true
      name: urls
      required: true
    description: Update the URL List with the values provided. The command will override
      the whole list content, rather than appending the new values.
    name: netskope-url-list-update
    outputs:
    - contextPath: Netskope.URLList.name
      description: The name of the URL list.
      type: String
    - contextPath: Netskope.URLList.URL
      description: The content the URL list.
      type: String
  - arguments:
    - description: Name of an existing file hash list shown in the Netskope UI on
        the file hash list page.
      name: name
      required: true
    - description: A comma-separated list of hashes.
      isArray: true
      name: hash
      required: true
    description: Update file hash list with the values provided. The command will
      override the whole list content, rather than appending the new values.
    name: netskope-file-hash-list-update
    outputs:
    - contextPath: FileHashList.name
      description: The name of the hash list.
      type: String
    - contextPath: FileHashList.hash
      description: The content of the hash list.
      type: String
  - arguments:
    - description: 'Free query on the clients, based on the client fields. For example,
        "host_info.hostname eq xxx". For more information, please visit Netskope documentation:
        https://docs.netskope.com/en/get-client-data.html.'
      name: query
    - defaultValue: "50"
      description: The maximum amount of clients to retrieve.
      name: limit
    - defaultValue: "1"
      description: The page number of the clients to retrieve (minimum is 1).
      name: page
    description: Get information about the Netskope clients.
    name: netskope-client-list
    outputs:
    - contextPath: Netskope.Client.client_id
      description: The ID of the Netskope client.
      type: String
    - contextPath: Netskope.Client.client_version
      description: The client version.
      type: String
    - contextPath: Netskope.Client.device_id
      description: The ID of the client's device.
      type: String
    - contextPath: Netskope.Client.host_info
      description: Information about the client's host.
      type: String
    - contextPath: Netskope.Client.last_event
      description: Information about the last event related to the client.
      type: String
    - contextPath: Netskope.Client.user_added_time
      description: The last time a client's user was added to Netskope.
      type: String
    - contextPath: Netskope.Client.users
      description: List of all users of the provided client.
      type: String
  - arguments:
    - description: The hostname to view its users. To view all hosts, go to the devices
        section inside the settings page.
      name: hostname
      required: true
    - defaultValue: "50"
      description: The maximum amount of users to retrieve.
      name: limit
    - defaultValue: "1"
      description: The page number of the users to retrieve (minimum is 1).
      name: page
    description: List all users of certain host by its hostname.
    name: netskope-host-associated-user-list
    outputs:
    - contextPath: Netskope.User.user_id
      description: The ID of the Netskope user.
      type: String
    - contextPath: Netskope.User.device_classification_status
      description: The device classification status.
      type: String
    - contextPath: Netskope.User.last_event
      description: Information about the last event related to the user.
      type: Unknown
    - contextPath: Netskope.User.user_source
      description: The source of the user.
      type: String
    - contextPath: Netskope.User.userkey
      description: The user key.
      type: String
    - contextPath: Netskope.User.username
      description: The name/email of the user.
      type: String
  - arguments:
    - description: The username to view its hosts. To view all users, go to the users
        section inside the settings page.
      name: username
      required: true
    - defaultValue: "50"
      description: The maximum amount of hosts to retrieve.
      name: limit
    - defaultValue: "1"
      description: The page number of the hosts to retrieve (minimum is 1).
      name: page
    description: List all hosts related to a certain username.
    name: netskope-user-associated-host-list
    outputs:
    - contextPath: Netskope.Host.nsdeviceuid
      description: Netskope device UID.
      type: String
    - contextPath: Netskope.Host.os
      description: The device operating system.
      type: String
    - contextPath: Netskope.Host.os_version
      description: The device operating system version.
      type: String
    - contextPath: Netskope.Host.device_model
      description: The device model.
      type: String
    - contextPath: Netskope.Host.hostname
      description: The hostname of the device.
      type: String
    - contextPath: Netskope.Host.agent_status
      description: The status of the agent on the device.
      type: String
  dockerimage: demisto/python3:3.10.13.78960
  isfetch: true
  runonce: false
  script: |
    register_module_line('NetskopeAPIv1', 'start', __line__())
    ### pack version: 3.3.1


    # type: ignore
    from copy import deepcopy
    from typing import Any, Dict, List, Optional, Tuple

    import urllib3



    # disable insecure warnings
    urllib3.disable_warnings()

    DEFAULT_PAGE = 1
    DEFAULT_LIMIT = 50
    DEFAULT_MAX_FETCH = DEFAULT_LIMIT
    DEFAULT_EVENTS_FETCH = DEFAULT_LIMIT
    DEFAULT_EVENT_TYPE = 'application'
    DEFAULT_FIRST_FETCH = '7 days'
    MAX_LIMIT = 100
    MAX_FETCH = 200
    MAX_EVENTS_FETCH = 200

    TIME_PERIOD_MAPPING = {
        'Last 60 Minutes': 3600,
        'Last 24 Hours': 86400,
        'Last 7 Days': 604800,
        'Last 30 Days': 2592000,
        'Last 60 Days': 5184000,
        'Last 90 Days': 7776000
    }


    class Client(BaseClient):
        """
        Client for Netskope RESTful API.

        Args:
            base_url (str): The base URL of Netskope.
            token (str): The token to authenticate against Netskope API.
            use_ssl (bool): Specifies whether to verify the SSL certificate or not.
            use_proxy (bool): Specifies if to use XSOAR proxy settings.
        """

        def __init__(self, base_url: str, token: str, use_ssl: bool, use_proxy: bool):
            super().__init__(urljoin(base_url, '/api/v1/'), verify=use_ssl, proxy=use_proxy)
            self._session.params['token'] = token   # type: ignore

        def list_events_request(self,
                                query: Optional[str] = None,
                                event_type: Optional[str] = None,
                                timeperiod: Optional[int] = None,
                                start_time: Optional[int] = None,
                                end_time: Optional[int] = None,
                                insertion_start_time: Optional[int] = None,
                                insertion_end_time: Optional[int] = None,
                                limit: Optional[int] = None,
                                skip: Optional[int] = None,
                                unsorted: Optional[bool] = None) -> Dict[str, Any]:
            """
            Get events extracted from SaaS traffic and or logs.

            Args:
                query (Optional[str]): Free query to filter the events.
                event_type (Optional[str]): Select events by their type.
                timeperiod (Optional[int]): Get all events from a certain time period.
                start_time (Optional[int]): Restrict events to those that have timestamps greater than the provided timestamp.
                end_time (Optional[int]): Restrict events to those that have timestamps less than or equal to the provided timestamp.
                insertion_start_time (Optional[int]): Restrict events to those that were inserted to the system
                    after the provided timestamp.
                insertion_end_time (Optional[int]): Restrict events to those that were inserted to the system
                    before the provided timestamp.
                limit (Optional[int]): The maximum amount of events to retrieve (up to 10000 events).
                skip (Optional[int]): The skip number of the events to retrieve (minimum is 1).
                unsorted (Optional[bool]): If true, the returned data will not be sorted (useful for improved performance).

            Returns:
                Dict[str, Any]: Netskope events.
            """

            body = remove_empty_elements({
                'query': query,
                'type': event_type,
                'timeperiod': timeperiod,
                'starttime': start_time,
                'endtime': end_time,
                'insertionstarttime': insertion_start_time,
                'insertionendtime': insertion_end_time,
                'limit': limit,
                'skip': skip,
                'unsorted': unsorted
            })

            return self._http_request(method='POST', url_suffix='events', json_data=body)

        def list_alerts_request(self,
                                query: Optional[str] = None,
                                alert_type: Optional[str] = None,
                                acked: Optional[bool] = None,
                                timeperiod: Optional[int] = None,
                                start_time: Optional[int] = None,
                                end_time: Optional[int] = None,
                                insertion_start_time: Optional[int] = None,
                                insertion_end_time: Optional[int] = None,
                                limit: Optional[int] = None,
                                skip: Optional[int] = None,
                                unsorted: Optional[bool] = None) -> Dict[str, Any]:
            """
            Get alerts generated by Netskope, including policy, DLP, and watch list alerts.

            Args:
                query (Optional[str]): Free query to filter the alerts.
                alert_type (Optional[str]): Select alerts by their type.
                acked (Optional[bool]): Whether to retrieve acknowledged alerts or not.
                timeperiod (Optional[int]): Get alerts from certain time period.
                start_time (Optional[int]): Restrict alerts to those that have timestamps greater than the provided timestamp.
                end_time (Optional[int]): Restrict alerts to those that have timestamps less than or equal to the provided timestamp.
                insertion_start_time (Optional[int]): Restrict alerts which have been inserted into the system
                    after the provided timestamp.
                insertion_end_time (Optional[int]): Restrict alerts which have been inserted into the system
                    before the provided timestamp.
                limit (Optional[int]): The maximum number of alerts to return (up to 10000).
                skip (Optional[int]): The skip number of the alerts to retrieve (minimum is 1).
                unsorted (Optional[bool]): If true, the returned data will not be sorted (useful for improved performance).

            Returns:
                Dict[str, Any]: Netskope alerts.
            """

            body = remove_empty_elements({
                'query': query,
                'alert_type': alert_type,
                'acked': acked,
                'timeperiod': timeperiod,
                'starttime': start_time,
                'endtime': end_time,
                'insertionstarttime': insertion_start_time,
                'insertionendtime': insertion_end_time,
                'limit': limit,
                'skip': skip,
                'unsorted': unsorted
            })

            return self._http_request(method='POST', url_suffix='alerts', json_data=body)

        def list_quarantined_files_request(self,
                                           start_time: Optional[int] = None,
                                           end_time: Optional[int] = None,
                                           limit: Optional[int] = None,
                                           skip: Optional[int] = None) -> Dict[str, Any]:
            """
            List all quarantined files.

            Args:
                start_time (Optional[int]): Get files last modified within a certain time period.
                end_time (Optional[int]): Get files last modified within a certain time period.
                limit (Optional[int]): The maximum amount of clients to retrieve (up to 10000).
                skip (Optional[int]): The skip number of the clients to retrieve (minimum is 1).

            Returns:
                Dict[str, Any]: Netskope quarantine files.
            """

            body = remove_empty_elements({
                'starttime': start_time,
                'endtime': end_time,
                'limit': limit,
                'skip': skip,
                'op': 'get-files'
            })

            return self._http_request(method='POST', url_suffix='quarantine', json_data=body)

        def get_quarantined_file_request(self, quarantine_profile_id: str, file_id: str) -> bytes:
            """
            Download a quarantined file.

            Args:
                quarantine_profile_id (str): The ID of quarantine profile.
                file_id (str): The ID of the quarantined file.

            Returns:
                bytes: The quarantined file content.
            """

            body = {
                'quarantine_profile_id': quarantine_profile_id,
                'file_id': file_id,
                'op': 'download-url'
            }

            return self._http_request(method='POST',
                                      url_suffix='quarantine',
                                      json_data=body,
                                      resp_type='content')

        def update_quarantined_file_request(self, quarantine_profile_id: str, file_id: str,
                                            action: str) -> None:
            """
            Take an action on a quarantined file.

            Args:
                quarantine_profile_id (str): The profile id of the quarantined file.
                file_id (str): The id of the quarantined file.
                action (str): Action to be performed on a quarantined.
            """

            body = {
                'quarantine_profile_id': quarantine_profile_id,
                'file_id': file_id,
                'action': action,
                'op': 'take-action'
            }

            self._http_request(method='POST', url_suffix='quarantine', json_data=body, resp_type='text')

        def update_url_list_request(self, name: str, urls: List[str]) -> None:
            """
            Update the URL List with the values provided.

            Args:
                name (str): Name of an existing URL List shown in the Netskope UI on the URL List skip.
                urls (List[str]): The content of the URL list.
            """

            body = {'name': name, 'list': ','.join(urls)}
            self._http_request(method='POST', url_suffix='updateUrlList', json_data=body)

        def update_file_hash_list_request(self, name: str, hashes: List[str]) -> None:
            """
            Update file hash list with the values provided.

            Args:
                name (str): Name of an existing file hash list shown in the Netskope UI on the file hash list skip.
                hashes (str): List of file hashes (md5 or sha256).
            """

            body = {'name': name, 'list': ','.join(hashes)}
            return self._http_request(method='POST', url_suffix='updateFileHashList', json_data=body)

        def list_clients_request(self,
                                 query: Optional[str] = None,
                                 limit: Optional[int] = None,
                                 skip: Optional[int] = None) -> Dict[str, Any]:
            """
            Get information about the Netskope clients.

            Args:
                query (Optional[str]): Free query on the clients, based on the client fields.
                limit (Optional[int]): The maximum amount of clients to retrieve (up to 10000).
                skip (Optional[int]): The skip number of the clients to retrieve (minimum is 1).

            Returns:
                Dict[str, Any]: The clients information.
            """

            body = remove_empty_elements({'query': query, 'limit': limit, 'skip': skip})
            return self._http_request(method='POST', url_suffix='clients', params=body)

        def _http_request(self, *args, **kwargs):
            response = super()._http_request(*args, **kwargs)
            if isinstance(response, dict) and 'errors' in response:
                errors = '\n'.join(response['errors'])
                raise DemistoException(f'Invalid API call: {errors}', res=response)

            return response


    def arg_to_boolean(arg: Optional[str]) -> Optional[bool]:
        """
        Converts an XSOAR argument to a Python boolean or None.

        Args:
            arg (Optional[str]): The argument to convert.

        Returns:
            Optional[bool]: A boolean if arg can be converted,
            or None if arg is None.
        """

        if arg is None:
            return None

        return argToBoolean(arg)


    def arg_to_seconds_timestamp(arg: Optional[str]):
        """
        Converts an XSOAR date string argument to a timestamp in seconds.

        Args:
            arg (Optional[str]): The argument to convert.

        Returns:
            Optional[int]: A timestamp if arg can be converted,
            or None if arg is None.
        """

        if arg is None:
            return None

        return date_to_seconds_timestamp(arg_to_datetime(arg))  # type: ignore


    def date_to_seconds_timestamp(date_str_or_dt: Union[str, datetime]) -> int:
        """
        Converts date string or datetime object to a timestamp in seconds.

        Args:
            date_str_or_dt (Union[str, datetime]): The datestring or datetime.

        Returns:
            int: The timestamp in seconds.
        """

        return date_to_timestamp(date_str_or_dt) // 1000


    def validate_time_arguments(start_time: Optional[int] = None,
                                end_time: Optional[int] = None,
                                insertion_start_time: Optional[int] = None,
                                insertion_end_time: Optional[int] = None,
                                timeperiod: Optional[int] = None) -> None:
        """
        Validates time arguments from the user.
        The user must provide one of the following:
            - start_time and end_time.
            - insertion_start_time and insertion_end_time.
            - timeperiod.

        Args:
            start_time (Optional[int], optional): The start time to fetch from the API.
            end_time (Optional[int], optional): The end time to fetch from the API.
            insertion_start_time (Optional[int], optional): The insertion start time to fetch from the API.
            insertion_end_time (Optional[int], optional): The insertion end time to fetch from the API.
            timeperiod (Optional[str], optional): The timeperiod to fetch from the API.

        Raises:
            DemistoException: The user did not provide valid timestamp.
        """

        combination = (all((start_time, end_time)), all(
            (insertion_start_time, insertion_end_time)), bool(timeperiod))

        if not any(combination):
            raise DemistoException('Missing time arguments. Please provide start_time and end_time, '
                                   'or insertion_start_time and or insertion_end_time or timeperiod.')
        if combination.count(True) > 1:
            raise DemistoException(
                'Invalid time arguments. Please provide only start_time and end_time, '
                'or insertion_start_time and or insertion_end_time or timeperiod. '
                'You must not combine between the mentioned options.')


    def validate_fetch_params(max_fetch: int, max_events_fetch: int, fetch_events: bool,
                              first_fetch: str, event_types: List[str]) -> None:
        """
        Validates the parameters for fetch incident command.

        Args:
            max_fetch: (int): The maximum number of incidents for one fetch.
            max_events_fetch (int) The maximum number of events per incident for one fetch.
            fetch_events (bool): Whether or not fetch events when fetching incident.
            first_fetch: (str): First fetch time in words.
        """

        if first_fetch:
            arg_to_datetime(first_fetch)  # verify that it is a date.

        if max_fetch > MAX_FETCH:
            return_error(f'The Maximum number of incidents per fetch should not exceed {MAX_FETCH}.')
        if fetch_events and max_events_fetch > MAX_EVENTS_FETCH:
            return_error(
                f'The Maximum number of events for each incident per fetch should not exceed {MAX_EVENTS_FETCH}.'
            )

        if not isinstance(event_types, list):
            return_error('The fetched event types must be a list.')


    def get_pagination_readable_message(header: str, page: int, limit: int) -> str:
        return f'{header}\n Current page size: {limit}\n Showing page {page} out of others that may exist.'


    def get_pagination_arguments(args: Dict[str, Any]) -> Tuple[int, int, int]:
        """
        Gets and validates pagination arguments for client (skip and limit).

        Args:
            args (Dict[str, Any]): The command arguments (page and limit).

        Returns:
            Tuple[int, int]: The page, calculated skip and limit after validation.
        """

        page = arg_to_number(args.get('page')) or DEFAULT_PAGE
        limit = arg_to_number(args.get('limit')) or DEFAULT_LIMIT

        if page < 1:
            raise DemistoException('Page argument must be greater than 1')
        if not 1 <= limit <= MAX_LIMIT:
            raise DemistoException(f'Limit argument must be between 1 to {MAX_LIMIT}')

        return page, (page - 1) * limit, limit


    def list_events_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Get events extracted from SaaS traffic and or logs.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        query = args.get('query')
        event_type = args['event_type']
        timeperiod = TIME_PERIOD_MAPPING.get(args.get('timeperiod', ''))
        start_time = arg_to_seconds_timestamp(args.get('start_time'))
        end_time = arg_to_seconds_timestamp(args.get('end_time'))
        insertion_start_time = arg_to_seconds_timestamp(args.get('insertion_start_time'))
        insertion_end_time = arg_to_seconds_timestamp(args.get('insertion_end_time'))
        page, skip, limit = get_pagination_arguments(args)
        unsorted = arg_to_boolean(args.get('unsorted'))

        validate_time_arguments(start_time=start_time,
                                end_time=end_time,
                                timeperiod=timeperiod,
                                insertion_start_time=insertion_start_time,
                                insertion_end_time=insertion_end_time)

        response = client.list_events_request(query=query,
                                              event_type=event_type,
                                              timeperiod=timeperiod,
                                              start_time=start_time,
                                              end_time=end_time,
                                              insertion_start_time=insertion_start_time,
                                              insertion_end_time=insertion_end_time,
                                              limit=limit,
                                              skip=skip,
                                              unsorted=unsorted)
        outputs = deepcopy(response['data'])
        for event in outputs:
            event['event_id'] = event['_id']
            event['timestamp'] = timestamp_to_datestring(event['timestamp'] * 1000)

        readable_output = tableToMarkdown(
            get_pagination_readable_message('Events List:', page=page, limit=limit),
            outputs,
            removeNull=True,
            headers=['event_id', 'timestamp', 'type', 'access_method', 'app', 'traffic_type'],
            headerTransform=string_to_table_header)

        return CommandResults(outputs_prefix='Netskope.Event',
                              outputs_key_field='event_id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=response)


    def list_alerts_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Get alerts generated by Netskope, including policy, DLP, and watch list alerts.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        query = args.get('query')
        alert_type = args.get('alert_type')
        acked = arg_to_boolean(args.get('acked'))
        timeperiod = TIME_PERIOD_MAPPING.get(args.get('timeperiod', ''))
        start_time = arg_to_seconds_timestamp(args.get('start_time'))
        end_time = arg_to_seconds_timestamp(args.get('end_time'))
        insertion_start_time = arg_to_seconds_timestamp(args.get('insertion_start_time'))
        insertion_end_time = arg_to_seconds_timestamp(args.get('insertion_end_time'))
        page, skip, limit = get_pagination_arguments(args)
        unsorted = arg_to_boolean(args.get('unsorted'))

        validate_time_arguments(start_time=start_time,
                                end_time=end_time,
                                timeperiod=timeperiod,
                                insertion_start_time=insertion_start_time,
                                insertion_end_time=insertion_end_time)

        response = client.list_alerts_request(query=query,
                                              alert_type=alert_type,
                                              acked=acked,
                                              timeperiod=timeperiod,
                                              start_time=start_time,
                                              end_time=end_time,
                                              insertion_start_time=insertion_start_time,
                                              insertion_end_time=insertion_end_time,
                                              limit=limit,
                                              skip=skip,
                                              unsorted=unsorted)
        outputs = deepcopy(response['data'])
        for alert in outputs:
            alert['alert_id'] = alert['_id']
            alert['timestamp'] = timestamp_to_datestring(alert['timestamp'] * 1000)

        readable_output = tableToMarkdown(
            get_pagination_readable_message('Alerts List:', page=page, limit=limit),
            outputs,
            removeNull=True,
            headers=['alert_id', 'alert_name', 'alert_type', 'timestamp', 'action'],
            headerTransform=string_to_table_header)

        return CommandResults(outputs_prefix='Netskope.Alert',
                              outputs_key_field='alert_id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=response)


    def list_quarantined_files_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        List all quarantined files.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        start_time = arg_to_seconds_timestamp(args.get('start_time'))
        end_time = arg_to_seconds_timestamp(args.get('end_time'))
        page, skip, limit = get_pagination_arguments(args)

        response = client.list_quarantined_files_request(start_time=start_time,
                                                         end_time=end_time,
                                                         limit=limit,
                                                         skip=skip)

        outputs = dict_safe_get(response, ['data', 'quarantined'])  # type: ignore
        for output in outputs:  # type: ignore
            for file_output in output['files']:
                file_output['quarantine_profile_id'] = output['quarantine_profile_id']
                file_output['quarantine_profile_name'] = output['quarantine_profile_name']
        outputs: list = sum((output['files'] for output in outputs), [])

        readable_header = get_pagination_readable_message('Quarantined Files List:',
                                                          page=page,
                                                          limit=limit)
        readable_output = tableToMarkdown(readable_header,
                                          outputs,
                                          removeNull=True,
                                          headers=[
                                              'quarantine_profile_id', 'quarantine_profile_name',
                                              'file_id', 'original_file_name', 'policy'
                                          ],
                                          headerTransform=string_to_table_header)

        return CommandResults(outputs_prefix='Netskope.Quarantine',
                              outputs_key_field='file_id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=response)


    def get_quarantined_file_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Download a quarantined file.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        quarantine_profile_id = args['quarantine_profile_id']
        file_id = args['file_id']

        response = client.get_quarantined_file_request(quarantine_profile_id=quarantine_profile_id,
                                                       file_id=file_id)

        return fileResult(filename=f'{file_id}.zip', data=response, file_type=EntryType.FILE)


    def update_quarantined_file_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Take an action on a quarantined file.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        quarantine_profile_id = args['quarantine_profile_id']
        file_id = args['file_id']
        action = args['action']

        client.update_quarantined_file_request(quarantine_profile_id=quarantine_profile_id,
                                               file_id=file_id,
                                               action=action)
        readable_output = f'## The file {file_id} was successfully {action}ed!'

        return CommandResults(readable_output=readable_output)


    def update_url_list_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Update the URL List with the values provided.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        name = args['name']
        urls = argToList(args['urls'])

        client.update_url_list_request(name=name, urls=urls)

        outputs = {'name': name, 'URL': urls}
        readable_output = f'URL List {name}:\n{", ".join(urls)}'

        return CommandResults(outputs_prefix='Netskope.URLList',
                              outputs_key_field='name',
                              outputs=outputs,
                              readable_output=readable_output)


    def update_file_hash_list_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Update file hash list with the values provided.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        name = args.get('name', '')
        hashes = argToList(args.get('hash'))

        client.update_file_hash_list_request(name=name, hashes=hashes)

        outputs = {'name': name, 'hash': hashes}
        readable_output = f'Hash List {name}:\n{", ".join(hashes)}'

        return CommandResults(outputs_prefix='Netskope.FileHashList',
                              outputs_key_field='name',
                              outputs=outputs,
                              readable_output=readable_output)


    def list_clients_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        Get information about the Netskope clients.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        query = args.get('query')
        page, skip, limit = get_pagination_arguments(args)

        response = client.list_clients_request(query=query, limit=limit, skip=skip)
        outputs = [client['attributes'] for client in response['data']]
        for output in outputs:
            output['client_id'] = output['_id']

        readable_header = get_pagination_readable_message('Clients List:', page=page, limit=limit)
        readable_output = tableToMarkdown(
            readable_header,
            outputs,
            removeNull=True,
            headers=['client_id', 'client_version', 'device_id', 'user_added_time'],
            headerTransform=string_to_table_header)
        return CommandResults(outputs_prefix='Netskope.Client',
                              outputs_key_field='client_id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=response)


    def list_host_associated_user_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        List all users of certain host by its hostname.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        hostname = args['hostname']
        page, skip, limit = get_pagination_arguments(args)

        response = client.list_clients_request(query=f'host_info.hostname eq {hostname}',
                                               limit=limit,
                                               skip=skip)

        outputs: list = sum((client['attributes'].get('users') for client in response['data']), [])
        for output in outputs:
            output['user_id'] = output['_id']

        readable_header = get_pagination_readable_message(f'Users Associated With {hostname}:',
                                                          page=page,
                                                          limit=limit)
        readable_output = tableToMarkdown(readable_header,
                                          outputs,
                                          removeNull=True,
                                          headers=['user_id', 'username', 'user_source'],
                                          headerTransform=string_to_table_header)

        return CommandResults(outputs_prefix='Netskope.User',
                              outputs_key_field='user_id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=response)


    def list_user_associated_host_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        List all hosts related to a certain username.

        Args:
            client (client): The Netskope client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: Command results with raw response, outputs and readable outputs.
        """

        username = args['username']
        page, skip, limit = get_pagination_arguments(args)

        response = client.list_clients_request(query=f'username eq {username}', limit=limit, skip=skip)

        outputs = []
        for client in response['data']:
            attributes = client['attributes']
            agent_status = dict_safe_get(attributes, ['last_event', 'status'])
            outputs.append({'agent_status': agent_status, **attributes['host_info']})

        readable_header = get_pagination_readable_message(f'Hosts Associated With {username}:',
                                                          page=page,
                                                          limit=limit)
        readable_output = tableToMarkdown(readable_header,
                                          outputs,
                                          removeNull=True,
                                          headers=['hostname', 'os_version', 'agent_status'],
                                          headerTransform=string_to_table_header)

        return CommandResults(outputs_prefix='Netskope.Host',
                              outputs_key_field='nsdeviceuid',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=response)


    def test_module(client: Client, max_fetch: int, first_fetch: str, fetch_events: bool,
                    max_events_fetch: int, event_types: List[str]) -> str:
        """
        Validates all integration parameters, and tests connection to Netskope instance.
        """

        validate_fetch_params(max_fetch, max_events_fetch, fetch_events, first_fetch, event_types)
        client.list_alerts_request(limit=1,
                                   skip=0,
                                   start_time=date_to_seconds_timestamp(datetime.now()),
                                   end_time=date_to_seconds_timestamp(datetime.now()))
        return 'ok'


    def fetch_multiple_type_events(client: Client, max_fetch: int, start_time: int,
                                   event_types: List[str],
                                   query: Optional[str]) -> List[Dict[str, Any]]:
        """
        Fetches events from multiple types.
        The function makes an API call for each type, since the API requires
        specifying the event type.

        Args:
            client (Client): The Netskope client.
            max_fetch (int): The maximum amount of events to fetch for each type.
            start_time (int): The time to fetch the events from.
            event_types (List[str]): The event types to fetch as incidents.
            query (Optional[str]): Query for filtering the events.

        Returns:
            List[Dict[str, Any]]: The fetched events.
        """

        events = []
        if event_types:
            max_fetch = max_fetch // len(event_types)

        for event_type in event_types:
            new_events = client.list_events_request(start_time=start_time,
                                                    end_time=date_to_seconds_timestamp(datetime.now()),
                                                    limit=max_fetch,
                                                    unsorted=False,
                                                    event_type=event_type,
                                                    query=query)['data']
            for event in new_events:
                event['event_id'] = event['_id']
                event['incident_type'] = event_type

            events.extend(new_events)

        return events


    def fetch_incidents(client: Client, max_fetch: int, first_fetch: str, fetch_events: bool,
                        max_events_fetch: int, event_types: List[str], alerts_query: Optional[str],
                        events_query: Optional[str]) -> None:
        """
        Fetches alerts and events as incidents.

        Args:
            client (Client): The Netskope client.
            max_fetch (int): Maximum number of incidents to fetch.
            first_fetch (str): The timestamp to fetch the incidents from.
            max_events_fetch (int): Maximum number of events to fetch.
            event_types (List[str]): The type of events to fetch.
            alerts_query (Optional[str]): Query for filtering the fetched alerts.
            events_query (Optional[str]): Query for filtering the fetched events.
        """

        validate_fetch_params(max_fetch, max_events_fetch, fetch_events, first_fetch, event_types)

        last_run = demisto.getLastRun() or {}
        first_fetch: int = arg_to_seconds_timestamp(first_fetch)

        last_alert_time = last_run.get('last_alert_time') or first_fetch
        alerts = client.list_alerts_request(start_time=last_alert_time,
                                            end_time=date_to_seconds_timestamp(datetime.now()),
                                            limit=max_fetch,
                                            query=alerts_query,
                                            unsorted=False)['data']

        last_event_time = last_run.get('last_event_time') or first_fetch
        if fetch_events:
            events = fetch_multiple_type_events(client,
                                                max_fetch=max_events_fetch,
                                                start_time=last_event_time,
                                                event_types=event_types,
                                                query=events_query)
        else:
            events = []

        incidents = []
        for alert in alerts:
            alert['incident_type'] = alert['alert_type']

            incidents.append({
                'name': alert['alert_name'],
                'occurred': timestamp_to_datestring(alert['timestamp']),
                'rawJSON': json.dumps(alert)
            })

        for event in events:
            incidents.append({
                'name': event['event_id'],
                'occurred': timestamp_to_datestring(event['timestamp']),
                'rawJSON': json.dumps(event)
            })

        # The alerts and events are sorted in descending order.
        # Also, we increment the timestamp in one second to avoid duplicates.
        demisto.setLastRun({
            'last_alert_time': alerts[0]['timestamp'] + 1 if alerts else last_alert_time,
            'last_event_time': events[0]['timestamp'] + 1 if events else last_event_time
        })
        demisto.incidents(incidents)


    def main():
        params = demisto.params()

        url = params['url']

        token = params['credentials']['password']
        use_ssl = not params.get('insecure', False)
        use_proxy = params.get('proxy', False)
        max_fetch = arg_to_number(params.get('max_fetch')) or DEFAULT_MAX_FETCH
        first_fetch = params.get('first_fetch', DEFAULT_FIRST_FETCH)
        fetch_events = argToBoolean(params.get('fetch_events', False))
        event_types = argToList(params.get('fetch_event_types', DEFAULT_EVENT_TYPE))
        max_events_fetch = arg_to_number(params.get('max_events_fetch')) or DEFAULT_EVENTS_FETCH

        client = Client(url, token, use_ssl, use_proxy)

        commands = {
            'netskope-event-list': list_events_command,
            'netskope-alert-list': list_alerts_command,
            'netskope-quarantined-file-list': list_quarantined_files_command,
            'netskope-quarantined-file-get': get_quarantined_file_command,
            'netskope-quarantined-file-update': update_quarantined_file_command,
            'netskope-url-list-update': update_url_list_command,
            'netskope-file-hash-list-update': update_file_hash_list_command,
            'netskope-client-list': list_clients_command,
            'netskope-host-associated-user-list': list_host_associated_user_command,
            'netskope-user-associated-host-list': list_user_associated_host_command,
        }

        try:
            command = demisto.command()

            if command == 'test-module':
                return_results(
                    test_module(client,
                                max_fetch=max_fetch,
                                first_fetch=first_fetch,
                                fetch_events=fetch_events,
                                max_events_fetch=max_events_fetch,
                                event_types=event_types))
            elif command == 'fetch-incidents':
                fetch_incidents(client,
                                max_fetch=max_fetch,
                                first_fetch=first_fetch,
                                fetch_events=fetch_events,
                                max_events_fetch=max_events_fetch,
                                event_types=event_types,
                                alerts_query=demisto.params().get('alerts_query'),
                                events_query=demisto.params().get('events_query'))
            elif command in commands:
                return_results(commands[command](client, demisto.args()))
            else:
                raise NotImplementedError(f'The command {command} does not exist!')
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{e}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('NetskopeAPIv1', 'end', __line__())
  subtype: python3
  type: python
system: true
